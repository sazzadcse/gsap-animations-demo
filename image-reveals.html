<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Image Reveal Animations</title>

	<!-- GSAP -->
	<script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
	<script src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>

	<style>
		* {
			box-sizing: border-box;
		}

		body {
			margin: 0;
			font-family: system-ui, sans-serif;
			overflow-x: hidden;
			background: #f5f5f5;
		}

		/* Control Panel Styles */
		.control-panel {
			position: fixed;
			top: 20px;
			right: 20px;
			width: 320px;
			background: white;
			border-radius: 12px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
			padding: 24px;
			z-index: 1000;
			max-height: 90vh;
			overflow-y: auto;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
		}

		.control-panel h3 {
			margin: 0 0 20px 0;
			font-size: 18px;
			color: #333;
			border-bottom: 2px solid #ff4c04;
			padding-bottom: 10px;
		}

		.control-group {
			margin-bottom: 20px;
		}

		.control-group label {
			display: block;
			font-size: 13px;
			font-weight: 600;
			color: #555;
			margin-bottom: 8px;
		}

		.control-group select,
		.control-group input[type="number"],
		.control-group input[type="text"] {
			width: 100%;
			padding: 10px;
			border: 2px solid #e0e0e0;
			border-radius: 6px;
			font-size: 14px;
			transition: border-color 0.3s;
		}

		.control-group select:focus,
		.control-group input[type="number"]:focus,
		.control-group input[type="text"]:focus {
			outline: none;
			border-color: #ff4c04;
		}

		.control-group .checkbox-wrapper {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.control-group .checkbox-wrapper input[type="checkbox"] {
			width: 18px;
			height: 18px;
			cursor: pointer;
		}

		.apply-btn {
			width: 100%;
			padding: 12px;
			background: #ff4c04;
			color: white;
			border: none;
			border-radius: 6px;
			font-size: 14px;
			font-weight: 600;
			cursor: pointer;
			transition: background 0.3s;
		}

		.apply-btn:hover {
			background: #e64400;
		}

		.control-group.disabled {
			opacity: 0.4;
			pointer-events: none;
		}

		.control-group.hidden {
			display: none;
		}

		/* Demo Section */
		.reveal {
			opacity: 0;
			visibility: hidden;
			position: relative;
			width: 100%;
			height: 100%;
			max-width: 100%;
			overflow: hidden;

			&.reveal--overlay {
				background-color: #189eff;
			}

			img {
				width: 100%;
				height: 100%;
				object-fit: cover;
				opacity: 0;
			}
		}

		* {
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		h1 {
			font-family: "Plus Jakarta Sans", sans-serif;
			font-size: 56px;
			font-weight: 800;
			line-height: 1.3;
			letter-spacing: -0.5px;
			color: #3c4043;
			text-align: center;

			& span {
				color: #ff4c04;
			}
		}

		h2 {
			font-family: "Plus Jakarta Sans", sans-serif;
			font-size: 32px;
			font-weight: 700;
			line-height: 40px;
			letter-spacing: -0.5px;
			color: #3c4043;
		}

		p {
			font-family: "Plus Jakarta Sans", sans-serif;
			font-size: 16px;
			font-weight: 300;
			line-height: 26px;
			margin-top: 16px;
			color: #3c4043;
		}

		img {
			display: block;
			width: 100%;
		}

		.container {
			display: flex;
			width: 100%;
			max-width: 1180px;
			margin: auto;
			justify-content: space-between;
			align-items: center;
			gap: 80px;
			padding: 120px 40px;

			.content--wrapper {
				width: 40%;

				.snippet--wrapper {
					background: #eef0f2;
					border-radius: 10px;
					font-family: "PT Mono", monospace;
					color: #ff4c04;
					padding: 16px;
					margin-top: 24px;
					font-size: 14px;
				}
			}

			.image--wrapper {
				width: 50%;
			}
		}

		#intro {
			justify-content: center;
			height: 100vh;

			.content--wrapper {
				width: 50%;
			}
		}

		.section-label {
			background: #ff4c04;
			color: white;
			padding: 8px 16px;
			border-radius: 20px;
			font-size: 12px;
			font-weight: 600;
			text-transform: uppercase;
			letter-spacing: 1px;
			margin-bottom: 16px;
			display: inline-block;
		}

		.config-display {
			background: #f8f9fa;
			border: 1px solid #e9ecef;
			border-radius: 8px;
			padding: 12px;
			margin-top: 12px;
			font-size: 12px;
			color: #666;
		}

		.config-display strong {
			color: #333;
		}

		/* Scroll spacer for demo */
		.scroll-spacer {
			height: 200px;
		}

		/* Slice Reveal Styles */
		.reveal .slice {
			position: absolute;
			top: 0;
			left: 0;
			overflow: hidden;
			will-change: transform, clip-path;
		}
	</style>

</head>

<body>

	<!-- Control Panel -->
	<div class="control-panel">
		<h3>⚙️ Animation Config</h3>

		<div class="control-group">
			<label>Animation Mode</label>
			<select id="animationMode">
				<option value="none">None</option>
				<option value="reveal">Reveal</option>
				<option value="scale">Scale</option>
				<option value="stretch">Stretch</option>
				<option value="sliceReveal">Slice Reveal</option>
			</select>
		</div>

		<div class="control-group" id="directionGroup">
			<label>Animation Direction</label>
			<select id="animationDirection">
				<option value="top">Top</option>
				<option value="left" selected>Left</option>
				<option value="right">Right</option>
				<option value="bottom">Bottom</option>
			</select>
		</div>

		<div class="control-group" id="sliceDirectionGroup" style="display: none;">
			<label>Slice Orientation</label>
			<select id="sliceOrientation">
				<option value="horizontal" selected>Horizontal (Columns)</option>
				<option value="vertical">Vertical (Rows)</option>
			</select>
		</div>

		<div class="control-group" id="sliceRevealDirectionGroup" style="display: none;">
			<label>Slice Reveal Direction</label>
			<select id="sliceRevealDirection">
				<option value="top-to-bottom" selected>Top to Bottom</option>
				<option value="bottom-to-top">Bottom to Top</option>
				<option value="left-to-right">Left to Right</option>
				<option value="right-to-left">Right to Left</option>
			</select>
		</div>

		<div class="control-group" id="numSlicesGroup" style="display: none;">
			<label>Number of Slices</label>
			<input type="number" id="numSlices" value="3" min="2" max="20" step="1">
		</div>



		<div class="control-group" id="staggerDelayGroup" style="display: none;">
			<label>Stagger Delay (seconds)</label>
			<input type="number" id="staggerDelay" value="0.25" step="0.05" min="0" max="2">
		</div>

		<div class="control-group" id="overlayGroup">
			<div class="checkbox-wrapper">
				<input type="checkbox" id="overlayEnabled">
				<label for="overlayEnabled" style="margin: 0;">Enable Overlay</label>
			</div>
		</div>
		<div class="control-group" id="overlayColorGroup" style="display: none;">
			<label>Overlay Color</label>
			<input type="color" id="overlayColor" value="#189eff" style="width: 100%; height: 40px; padding: 2px; border: 2px solid #e0e0e0; border-radius: 6px; cursor: pointer;">
		</div>

		<div class="control-group">
			<label>Animation Trigger Point</label>
			<select id="triggerPoint">
				<option value="top top">Top Top</option>
				<option value="top center" selected>Top Center</option>
				<option value="top bottom">Top Bottom</option>
				<option value="center top">Center Top</option>
				<option value="center center">Center Center</option>
				<option value="center bottom">Center Bottom</option>
				<option value="bottom top">Bottom Top</option>
				<option value="bottom center">Bottom Center</option>
				<option value="bottom bottom">Bottom Bottom</option>
				<option value="custom">Custom</option>
			</select>
		</div>

		<div class="control-group" id="customTriggerGroup" style="display: none;">
			<label>Custom Trigger (start)</label>
			<input type="text" id="customTriggerStart" value="top 80%" placeholder="e.g., top 80%">
		</div>

		<div class="control-group" id="scaleConfig">
			<label>Scale From</label>
			<input type="number" id="scaleFrom" value="0.5" step="0.1" min="0" max="2">
			<label style="margin-top: 8px;">Scale To</label>
			<input type="number" id="scaleTo" value="1" step="0.1" min="0" max="2">
		</div>

		<div class="control-group">
			<label>Animation Duration (seconds)</label>
			<input type="number" id="animationDuration" value="1" step="0.1" min="0.1" max="5">
		</div>

		<div class="control-group">
			<label>Easing Function</label>
			<select id="easingFunction">
				<option value="power1.inOut">Power1 InOut</option>
				<option value="power2.inOut">Power2 InOut</option>
				<option value="power3.inOut">Power3 InOut</option>
				<option value="power4.inOut" selected>Power4 InOut</option>
				<option value="back.out">Back Out</option>
				<option value="elastic.out">Elastic Out</option>
				<option value="bounce.out">Bounce Out</option>
			</select>
		</div>

		<button class="apply-btn" onclick="applyConfiguration()">Apply Configuration</button>
	</div>

	<div id="intro" class="container">
		<div class="content--wrapper">
			<h1>Advanced <span>Image Reveal</span> Animations</h1>
			<p>Use the control panel to configure different animation modes, directions, trigger points, and more.</p>
		</div>
	</div>

	<!-- Demo Section -->
	<section class="container">

		<div class="image--wrapper">
			<div class="reveal reveal--left" id="reveal">
				<img src="https://unsplash.it/1200/1400" alt="Demo Image">
			</div>
		</div>
	</section>

	<!-- Additional scroll space for testing -->
	<div style="height: 100vh;"></div>

	<script>
		// Register GSAP plugins
		gsap.registerPlugin( ScrollTrigger );

		// Global configuration object
		let config = {
			mode: 'reveal',
			direction: 'left',
			overlayEnabled: true,
			triggerPoint: 'top center',
			customTriggerStart: 'top 80%',
			scaleFrom: 0.5,
			scaleTo: 1,
			duration: 1,
			easing: 'power4.inOut',
			sliceOrientation: 'horizontal',
			sliceRevealDirection: 'top-to-bottom',
			numSlices: 3,
			overlayColor: '#189eff',
			staggerDelay: 0.25
		};

		// Store ScrollTrigger instances for cleanup
		let scrollTriggers = [];

		// Get easing function from string
		function getEasing ( easingString ) {
			const easingMap = {
				'power1.inOut': 'power1.inOut',
				'power2.inOut': 'power2.inOut',
				'power3.inOut': 'power3.inOut',
				'power4.inOut': 'power4.inOut',
				'back.out': 'back.out(1.7)',
				'elastic.out': 'elastic.out(1, 0.3)',
				'bounce.out': 'bounce.out'
			};
			return easingMap[ easingString ] || 'power4.inOut';
		}

		// Get clip path based on direction
		function getClipPath ( direction ) {
			const clipPaths = {
				'left': 'inset(0 0 0 100%)',
				'right': 'inset(0 100% 0 0)',
				'top': 'inset(0 0 100% 0)',
				'bottom': 'inset(100% 0 0 0)'
			};
			return clipPaths[ direction ] || 'inset(0 0 0 100%)';
		}

		// Get transform origin based on direction
		function getTransformOrigin ( direction ) {
			const origins = {
				'left': 'left center',
				'right': 'right center',
				'top': 'center top',
				'bottom': 'center bottom'
			};
			return origins[ direction ] || 'left center';
		}

		// Apply animation based on mode
		function applyAnimation ( container, image, mode, direction, overlayEnabled, triggerPoint, customTriggerStart, scaleFrom, scaleTo, duration, easing ) {
			// If mode is 'none', just show the images without any animation
			if ( mode === 'none' ) {
				gsap.set( container, { autoAlpha: 1, clearProps: 'all' } );
				gsap.set( image, { autoAlpha: 1, clearProps: 'all' } );
				return null; // Don't create a timeline or ScrollTrigger
			}

			const tl = gsap.timeline( {
				scrollTrigger: {
					trigger: container,
					start: triggerPoint === 'custom' ? customTriggerStart : triggerPoint,
					end: 'bottom top',
					toggleActions: 'play none none none'
				}
			} );

			// Store timeline for cleanup
			scrollTriggers.push( tl );

			// Set initial visibility
			tl.set( container, { autoAlpha: 1 } );
			tl.set( image, { autoAlpha: 1 } );

			switch ( mode ) {
				case 'reveal':
					applyRevealAnimation( tl, container, image, direction, overlayEnabled, duration, easing );
					break;
				case 'scale':
					applyScaleAnimation( tl, container, image, direction, overlayEnabled, scaleFrom, scaleTo, duration, easing );
					break;
				case 'stretch':
					applyStretchAnimation( tl, container, image, direction, overlayEnabled, duration, easing );
					break;
				case 'sliceReveal':
					applySliceRevealAnimation( tl, container, image, duration, easing );
					break;
			}

			return tl;
		}

		// Reveal animation
		function applyRevealAnimation ( tl, container, image, direction, overlayEnabled, duration, easing ) {
			const clipPath = getClipPath( direction );

			// Set initial state
			tl.set( image, { scale: 1.3 }, 0 );

			// Animate container clip path
			tl.from( container, {
				clipPath: clipPath,
				duration: duration,
				ease: easing
			}, 0 );

			// If overlay enabled, animate image clip path
			if ( overlayEnabled ) {
				tl.from( image, {
					clipPath: clipPath,
					duration: duration * 0.6,
					ease: easing
				}, duration * 0.4 );
			}

			// Animate image scale
			tl.to( image, {
				scale: 1,
				duration: duration * 1.2,
				ease: 'power2.out'
			}, 0 );
		}

		// Scale animation
		function applyScaleAnimation ( tl, container, image, direction, overlayEnabled, scaleFrom, scaleTo, duration, easing ) {
			const transformOrigin = getTransformOrigin( direction );

			tl.set( container, { overflow: 'visible' } );

			// Set initial scale to scaleFrom
			tl.set( image, {
				scale: scaleFrom,
				transformOrigin: transformOrigin
			}, 0 );

			// Animate from scaleFrom to scaleTo
			tl.to( image, {
				scale: scaleTo,
				transformOrigin: transformOrigin,
				duration: duration,
				ease: easing
			}, 0 );

			if ( overlayEnabled ) {
				const clipPath = getClipPath( direction );
				tl.from( container, {
					clipPath: clipPath,
					duration: duration * 0.8,
					ease: easing
				}, 0 );
			}
		}

		// Stretch animation
		function applyStretchAnimation ( tl, container, image, direction, overlayEnabled, duration, easing ) {
			const transformOrigin = getTransformOrigin( direction );

			tl.set( container, { overflow: 'visible' } );

			let stretchProps = {};
			switch ( direction ) {
				case 'left':
				case 'right':
					stretchProps = { scaleX: 0 };
					break;
				case 'top':
				case 'bottom':
					stretchProps = { scaleY: 0 };
					break;
			}

			tl.from( image, {
				...stretchProps,
				transformOrigin: transformOrigin,
				duration: duration,
				ease: easing
			} );

			if ( overlayEnabled ) {
				const clipPath = getClipPath( direction );
				tl.from( container, {
					clipPath: clipPath,
					duration: duration * 0.8,
					ease: easing
				}, 0 );
			}
		}

		// Slice Reveal animation - merged from slice-demo.html with smooth animation
		function applySliceRevealAnimation ( tl, container, image, duration, easing ) {
			// Clear existing slices
			const existingSlices = container.querySelectorAll( '.slice' );
			existingSlices.forEach( slice => slice.remove() );

			// Get container dimensions
			const containerWidth = container.offsetWidth;
			const containerHeight = container.offsetHeight;

			// Calculate slice dimensions based on sliceOrientation
			let sliceWidth, sliceHeight, numSlices = config.numSlices;
			const sliceOrientation = config.sliceOrientation;
			const sliceRevealDirection = config.sliceRevealDirection;

			if ( sliceOrientation === 'horizontal' ) {
				// For horizontal: create columns
				sliceWidth = containerWidth / numSlices;
				sliceHeight = containerHeight;
			} else {
				// For vertical: create rows
				sliceWidth = containerWidth;
				sliceHeight = containerHeight / numSlices;
			}

			// Create slices
			for ( let i = 0; i < numSlices; i++ ) {
				const slice = document.createElement( 'div' );
				slice.className = 'slice';
				slice.dataset.index = i;

				// Set slice dimensions and position
				if ( sliceOrientation === 'horizontal' ) {
					slice.style.width = sliceWidth + 'px';
					slice.style.height = sliceHeight + 'px';
					slice.style.left = ( i * sliceWidth ) + 'px';
					slice.style.top = '0';
				} else {
					slice.style.width = sliceWidth + 'px';
					slice.style.height = sliceHeight + 'px';
					slice.style.left = '0';
					slice.style.top = ( i * sliceHeight ) + 'px';
				}

				// Set overlay color for this slice
				slice.style.background = config.overlayColor;
				slice.style.zIndex = '10';

				container.appendChild( slice );
			}

			const slices = container.querySelectorAll( '.slice' );

			// Set initial clipPath based on sliceRevealDirection
			let initialClipPath, finalClipPath;

			if ( sliceRevealDirection === 'top-to-bottom' ) {
				// Slices disappear from top to bottom (vertical reveal)
				initialClipPath = 'inset(0 0 0 0)';
				finalClipPath = 'inset(0 0 100% 0)';
			} else if ( sliceRevealDirection === 'bottom-to-top' ) {
				// Slices disappear from bottom to top (vertical reveal)
				initialClipPath = 'inset(0 0 0 0)';
				finalClipPath = 'inset(100% 0 0 0)';
			} else if ( sliceRevealDirection === 'left-to-right' ) {
				// Slices disappear from left to right (horizontal reveal)
				initialClipPath = 'inset(0 0 0 0)';
				finalClipPath = 'inset(0 0 0 100%)';
			} else if ( sliceRevealDirection === 'right-to-left' ) {
				// Slices disappear from right to left (horizontal reveal)
				initialClipPath = 'inset(0 0 0 0)';
				finalClipPath = 'inset(0 100% 0 0)';
			}

			// Set initial state for all slices
			gsap.set( slices, {
				clipPath: initialClipPath
			} );

			// Determine stagger direction based on sliceRevealDirection
			let staggerDirection = 'start';
			if ( sliceRevealDirection === 'bottom-to-top' || sliceRevealDirection === 'right-to-left' ) {
				staggerDirection = 'end';
			}

			// Animate slices with smooth stagger - using amount for smoother animation
			tl.to( slices, duration, {
				clipPath: finalClipPath,
				ease: easing,
				stagger: {
					amount: config.staggerDelay
				}
			}, 'start' );

			// Animate image scale for smooth effect
			tl.to( image, duration * 1.2, {
				scale: 1.5,
				ease: easing
			}, 'start' );

			console.log( 'Slice reveal animation applied:', {
				orientation: sliceOrientation,
				direction: sliceRevealDirection,
				slices: numSlices,
				stagger: staggerDirection
			} );
		}

		// Main image reveal function
		function imageReveal () {
			// Kill existing triggers and timelines
			scrollTriggers.forEach( tl => {
				if ( tl ) {
					if ( tl.scrollTrigger ) {
						tl.scrollTrigger.kill();
					}
					tl.kill();
				}
			} );
			scrollTriggers = [];

			// Reset all reveal elements to initial state
			const revealContainers = document.querySelectorAll( '.reveal' );
			revealContainers.forEach( container => {
				const image = container.querySelector( 'img' );

				// For scale mode, image should be visible at initial scale
				if ( config.mode === 'scale' ) {
					gsap.set( container, {
						clearProps: 'all',
						autoAlpha: 1,
						overflow: 'visible'
					} );
					gsap.set( image, {
						clearProps: 'all',
						autoAlpha: 1,
						scale: config.scaleFrom
					} );
				} else if ( config.mode === 'sliceReveal' ) {
					// For sliceReveal mode, image should be visible and covered by slices
					gsap.set( container, {
						clearProps: 'all',
						autoAlpha: 1,
						overflow: 'hidden'
					} );
					gsap.set( image, {
						clearProps: 'all',
						autoAlpha: 1,
						scale: 1
					} );
				} else {
					gsap.set( container, {
						clearProps: 'all',
						opacity: 0,
						visibility: 'hidden'
					} );
					gsap.set( image, {
						clearProps: 'all',
						opacity: 0
					} );
				}
			} );

			// Small delay to ensure DOM is updated
			setTimeout( () => {
				applyAnimations( revealContainers );
				ScrollTrigger.refresh();
			}, 50 );
		}

		// Apply animations to containers
		function applyAnimations ( revealContainers ) {
			revealContainers.forEach( ( container ) => {
				const image = container.querySelector( 'img' );

				// Use config mode and direction
				let mode = config.mode;
				let direction = config.direction;

				const overlayEnabled = config.overlayEnabled;

				applyAnimation(
					container,
					image,
					mode,
					direction,
					overlayEnabled,
					config.triggerPoint,
					config.customTriggerStart,
					config.scaleFrom,
					config.scaleTo,
					config.duration,
					getEasing( config.easing )
				);
			} );
		}

		// Apply configuration from control panel
		function applyConfiguration () {
			// Get values from control panel
			config.mode = document.getElementById( 'animationMode' ).value;
			config.direction = document.getElementById( 'animationDirection' ).value;
			config.overlayEnabled = document.getElementById( 'overlayEnabled' ).checked;
			config.triggerPoint = document.getElementById( 'triggerPoint' ).value;
			config.customTriggerStart = document.getElementById( 'customTriggerStart' ).value;
			config.scaleFrom = parseFloat( document.getElementById( 'scaleFrom' ).value );
			config.scaleTo = parseFloat( document.getElementById( 'scaleTo' ).value );
			config.duration = parseFloat( document.getElementById( 'animationDuration' ).value );
			config.easing = document.getElementById( 'easingFunction' ).value;

			// Get sliceReveal specific settings
			if ( document.getElementById( 'sliceOrientation' ) ) {
				config.sliceOrientation = document.getElementById( 'sliceOrientation' ).value;
			}
			if ( document.getElementById( 'sliceRevealDirection' ) ) {
				config.sliceRevealDirection = document.getElementById( 'sliceRevealDirection' ).value;
			}
			if ( document.getElementById( 'numSlices' ) ) {
				config.numSlices = parseInt( document.getElementById( 'numSlices' ).value );
				if ( config.numSlices < 2 ) config.numSlices = 2;
				if ( config.numSlices > 20 ) config.numSlices = 20;
			}
			if ( document.getElementById( 'overlayColor' ) ) {
				config.overlayColor = document.getElementById( 'overlayColor' ).value;
			}
			if ( document.getElementById( 'staggerDelay' ) ) {
				config.staggerDelay = parseFloat( document.getElementById( 'staggerDelay' ).value );
			}

			// Update reveal container classes
			updateRevealClasses();

			// Re-run animations with new config
			imageReveal();

			// Update config display
			updateConfigDisplay();

			// Force ScrollTrigger refresh after configuration change
			setTimeout( () => {
				ScrollTrigger.refresh();
			}, 100 );

			console.log( 'Configuration applied:', config );
		}

		// Update reveal element classes based on config
		function updateRevealClasses () {
			const revealContainers = document.querySelectorAll( '.reveal' );

			revealContainers.forEach( ( container ) => {
				// Remove direction classes
				container.classList.remove( 'reveal--left', 'reveal--right', 'reveal--top', 'reveal--bottom' );
				container.classList.remove( 'reveal--scale', 'reveal--stretch', 'reveal--mask', 'reveal--sliceReveal' );
				container.classList.remove( 'reveal--overlay' );

				// Add mode class
				if ( config.mode !== 'sliceReveal' ) {
					container.classList.add( `reveal--${config.direction}` );
				}

				// Add overlay class if enabled
				if ( config.overlayEnabled ) {
					container.classList.add( 'reveal--overlay' );
				}
			} );
		}

		// Update config display text
		function updateConfigDisplay () {
			const element = document.getElementById( 'configDisplay' );
			if ( element ) {
				let text = `<strong>Current Config:</strong> Mode: ${config.mode.charAt( 0 ).toUpperCase() + config.mode.slice( 1 )}`;

				if ( config.mode === 'sliceReveal' ) {
					const orientationText = config.sliceOrientation === 'horizontal' ? 'Horizontal (Columns)' : 'Vertical (Rows)';
					const directionText = config.sliceRevealDirection.replace( /-/g, ' ' ).replace( /\b\w/g, l => l.toUpperCase() );
					text += `, Orientation: ${orientationText}`;
					text += `, Direction: ${directionText}`;
					text += `, Slices: ${config.numSlices}`;
					text += `, Stagger: ${config.staggerDelay}s`;
				} else {
					text += `, Direction: ${config.direction.charAt( 0 ).toUpperCase() + config.direction.slice( 1 )}`;
				}

				if ( config.mode === 'scale' ) {
					text += `, From: ${config.scaleFrom}, To: ${config.scaleTo}`;
				}
				text += `, Overlay: ${config.overlayEnabled ? 'Enabled' : 'Disabled'}`;
				text += `, Trigger: ${config.triggerPoint}`;
				element.innerHTML = text;
			}

			// Update snippet
			const snippet = document.getElementById( 'snippet' );
			if ( snippet ) {
				let snippetText = `.reveal`;
				if ( config.mode === 'sliceReveal' ) {
					snippetText += ` .slice:nth-child(${config.numSlices})`;
				} else {
					snippetText += ` .reveal--${config.direction}`;
				}
				if ( config.overlayEnabled ) {
					snippetText += ' .reveal--overlay';
				}
				snippet.textContent = snippetText;
			}
		}

		// Show/hide custom trigger input
		document.getElementById( 'triggerPoint' ).addEventListener( 'change', function () {
			const customGroup = document.getElementById( 'customTriggerGroup' );
			if ( this.value === 'custom' ) {
				customGroup.style.display = 'block';
			} else {
				customGroup.style.display = 'none';
			}
		} );

		// Show/hide controls based on mode
		function updateControlVisibility () {
			const mode = document.getElementById( 'animationMode' ).value;
			const directionGroup = document.getElementById( 'directionGroup' );
			const sliceDirectionGroup = document.getElementById( 'sliceDirectionGroup' );
			const sliceRevealDirectionGroup = document.getElementById( 'sliceRevealDirectionGroup' );
			const numSlicesGroup = document.getElementById( 'numSlicesGroup' );
			const overlayColorGroup = document.getElementById( 'overlayColorGroup' );
			const staggerDelayGroup = document.getElementById( 'staggerDelayGroup' );

			// Hide direction controls for scale mode
			if ( mode === 'scale' ) {
				directionGroup.classList.add( 'hidden' );
			} else {
				directionGroup.classList.remove( 'hidden' );
			}

			// Show sliceReveal specific controls
			if ( mode === 'sliceReveal' ) {
				sliceDirectionGroup.style.display = 'block';
				sliceRevealDirectionGroup.style.display = 'block';
				numSlicesGroup.style.display = 'block';
				overlayColorGroup.style.display = 'block';
				staggerDelayGroup.style.display = 'block';
			} else {
				sliceDirectionGroup.style.display = 'none';
				sliceRevealDirectionGroup.style.display = 'none';
				numSlicesGroup.style.display = 'none';
				overlayColorGroup.style.display = 'none';
				staggerDelayGroup.style.display = 'none';
			}

			// Overlay is now available for all animation modes
		}

		// Update control visibility when mode changes
		document.getElementById( 'animationMode' ).addEventListener( 'change', updateControlVisibility );

		// Initialize on page load
		window.addEventListener( 'load', function () {
			imageReveal();
			updateConfigDisplay();
			updateControlVisibility();
		} );

		// Refresh on resize
		let resizeTimer;
		window.addEventListener( 'resize', function () {
			clearTimeout( resizeTimer );
			resizeTimer = setTimeout( function () {
				ScrollTrigger.refresh();
			}, 250 );
		} );
	</script>

</body>

</html>